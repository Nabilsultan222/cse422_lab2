# -*- coding: utf-8 -*-
"""

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qw8lMxHne-i86iR5kTX-JX9jC4Am9OmY
"""
#task-1
import random

def fitness_check(chromosome, historical_prices, initial_capital=1000):
    capital = initial_capital
    for i in historical_prices:
        trade_size = capital * (chromosome["trade_size"] / 100)
        if i < -chromosome["stop_loss"]:
            capital -= trade_size * (chromosome["stop_loss"] / 100)
        elif i > chromosome["take_profit"]:
            capital += trade_size * (chromosome["take_profit"] / 100)
        else:
            capital += trade_size * ( i / 100)
    return capital - initial_capital


def selection(population, historical_prices):
    fitness_scores = [fitness_check(chrom, historical_prices) for chrom in population]
    total_fitness = sum(fitness_scores)
    if total_fitness == 0:
        return random.choice(population), random.choice(population)
    selection_probabilities = [fitness / total_fitness for fitness in fitness_scores]
    parent1, parent2 = random.choices(population, weights=selection_probabilities, k=2)
    return parent1, parent2

def crossover(parent1, parent2):
    crosspoint = random.choice(["stop_loss", "take_profit", "trade_size"])
    child1 = {**parent1, crosspoint: parent2[crosspoint]}
    child2 = {**parent2, crosspoint: parent1[crosspoint]}
    return child1, child2

def mutation(chromosome, mutation_rate=0.05):
    for i in chromosome:
        if random.random() < mutation_rate:
            chromosome[i] = random.uniform(1, 99)
    return chromosome

def genetic_algorithm(historical_prices, initial_population, generations):
    population = initial_population
    for generation in range(generations):
        fitness_scores = [fitness_check(chrom, historical_prices) for chrom in population]
        max_fitness = max(fitness_scores)
        best_chromosome = population[fitness_scores.index(max_fitness)]

        next_generation = [best_chromosome]
        for _ in range(len(population) - 1):
            parent1, parent2 = selection(population, historical_prices)
            child1, child2 = crossover(parent1, parent2)
            next_generation.append(mutation(child1))
            next_generation.append(mutation(child2))
        population = next_generation[:len(population)]

    fitness_scores = [fitness_check(chrom, historical_prices) for chrom in population]
    best_chromosome = population[fitness_scores.index(max(fitness_scores))]
    return best_chromosome, round(max(fitness_scores),2)

historical_prices = [-1.2, 3.4, -0.8, 2.1, -2.5, 1.7, -0.3, 5.8, -1.1, 3.5]
initial_population = [
    {"stop_loss": 2, "take_profit": 5, "trade_size": 20},
    {"stop_loss": 3, "take_profit": 7, "trade_size": 30},
    {"stop_loss": 1.5, "take_profit": 4, "trade_size": 25},
    {"stop_loss": 2.5, "take_profit": 6, "trade_size": 15}
]
generations = 10

best_strategy, final_profit = genetic_algorithm(historical_prices, initial_population, generations)
print("Best Strategy:", best_strategy)
print("Final Profit:", final_profit)


#task-2

import random


initial_population = [
    "000111000",
    "111000111",
    "101010101",
    "010101010",
    "110011001",
    "001100110"
]

def two_point_crossover(parent1, parent2):

    parent1 = list(parent1)
    parent2 = list(parent2)
    point1 = random.randint(2, 3)
    point2 = random.randint(6, 7)
    child1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
    child2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]

    child1 = ''.join(child1)
    child2 = ''.join(child2)

    print("Parent 1:", ''.join(parent1))
    print("Parent 2:", ''.join(parent2))
    print(f"Point1: {point1}, Point2: {point2}")
    print("Offspring 1:", child1)
    print("Offspring 2:", child2)

parent1 = random.choice(initial_population)
parent2 = random.choice(initial_population)
while parent1 == parent2:
    parent2 = random.choice(initial_population)

two_point_crossover(parent1, parent2)
